# Kafka란
> Apache Kafka는 실시간으로 기록 스트림을 게시, 구독, 저장 및 처리할 수 있는 분산 데이터 스트리밍 플랫폼  
> 여러 소스에서 데이터 스트림을 처리하고 여러 사용자에게 전달하도록 설계  
> A -> B 이동만이 아닌 A -> Z 지점을 비롯한 모든 곳에서 대규모 데이터를 동시에 이동할 수 있는 것.

`Apache Kafka는 전통적인 엔터프라이즈 메시징 시스템의 대안`

---  

# Apache Kafka, 마이크로서비스, 스트리밍 데이터

> `마이크로서비스` -> 공유 데이터베이스 계층과 같은 종속성을 줄여 민첩하게 작업을 수행  
> 개발자가 구축 중인 분산형 애플리케이션이 데이터를 공유하기 위한 통합 옵션으로 동기식 방법이 있는데, 이는 서로 다른 사용자 간 데이터를 공유하는 데 애플리케이션 프로그래밍 인터페이스(Application Programming Interface, API)를 활용

> 또 다른 통합 옵션으로는 중간 스토어에서 데이터를 복제하는 비동기식 방법이 있다.  
> Apache Kafka는 바로 이런 맥락에 등장하는 솔루션으로, 다른 개발팀의 데이터를 스트리밍하여 데이터 스토어를 채우면 해당 데이터를 여러 팀과 이들의 애플리케이션 간에 공유할 수 있게 된다.  
    >> - 느슨한 결합
    >>     - 클라우드 시대가 열리며 컴퓨터 리소스는 더 이상 영속적이지 않고 각 컴포넌트들을 견고한 결합으로 연결할 수 없게 되었다. -> 컴퓨터 통신은 직접 통신 대신 메시징 프레임워크 기반으로 간접적으로 데이터를 주고 받는 형태를 취함
    >> - 데이터 중앙화
    >>      - 많은 서비스에서 생성되는 모든 이벤트의 부하를 견딜만한 버스 시스템이 없었음
    >>      - 강력한 메시지 처리 성능, 수평확장성, 고장감내성에 기반한 이벤트 버스 애플리케이션인 `kafka` 도입으로 고효율의 분석 기술이 가능해졌다.

`카프카란 - 비동기 통신 방식으로 큰 규모의 데이터를 아주 빠르게 처리할 수 있는 애플리케이션이다.`

### 3가지 기반 기능을 필요

- 분산형 통합
  - 필요한 경우 지속적으로 배포할 수 있는 경량의 패턴 기반 통합으로, 중앙집중식 ESB 유형 배포의 제약을 받지 않음.
- API
  - 파트너, 고객 및 개발자로 이루어진 에코시스템을 구현하는 API 기반 서비스로, 신뢰성과 수익성을 갖춘 유용한 활용 방안을 제공.
- 컨테이너
  - 클라우드 네이티브 방식의 커넥티드 애플리케이션을 개발, 관리 및 확장하는 플랫폼
  - 컨테이너는 개별 배포 방식으로 데브옵스(DevOps) 프로세스에 포함되면서, 즉시 사용 가능한 클러스터링에 의해 지원되는 린(lean) 아티팩트 개발을 사용할 수 있도록 함으로써 고가용성을 보장.


## 동작 원리
> 기본적으로 메시징 서버로 동작.

- 프로듀서 or 퍼블리셔 : 메시지라고 불리는 데이터 단위를 보내는 측
- 컨슈머 or 서브스크라이버 : 메시지를 가져가는 측
```
- 중앙에 메시징 시스템 서버를 두고 메시지를 보내고 (publish) 받는 (subscribe) 형태의 통신을 펍/섭 모델이라고 한다.
- 펍/섭은 비동기 메시징 전송 방식으로서, 발신자의 메시지에는 수신자가 정해져있지 않은 상태로 발행한다. 구독을 신청한 수신자만이 정해진 메시지를 받을 수 있고 이러한 구조 덕분에 다이나믹한 네트워크 토폴로지와 높은 확장성을 확보할 수 있다.
```

**펍/섭 모델의 특징**

- 프로듀서가 컨슈머에게 메시지를 직접 전달하지 않고, 중간의 메시싱 시스템에 전달한다.  
- 컨슈머가 불능 상태가 되더라도 프로듀서는 메시지를 메시징 시스템에 전달할 수 있으며, 메시지는 유실되지 않는다. 그리고 컨슈머가 회복되면 다시 메시지를 가져간다.  
- 각각의 개체가 N:N 통신을 하는것이 아니기 때문에 확장이 용이하다.
메시지가 정확하게 전달되었는지 확인하려면 코드가 복잡해진다.
- 메시지 전달 속도가 빠르지 않다. (중간에 메시징 시스템이 있기 때문에)


**기존 메시징 시스템의 특징**

- 메시지의 보관, 교환, 전달 과정에서 신뢰성을 보장하는 것에 중점을 맞췄기 때문에 속도와 용량은 그렇게 중요하지 않았음
- 카프카는 성능 단점을 극복하기 위해, 메시지 교환 전달의 신뢰성 관리를 프로듀서와 컨슈머 쪽으로 넘김
- 메시징 시스템 내에서의 작업량을 줄이고 이렇게 절약한 작업량을 메시징 전달 성능에 집중시켜서 고성능 메시징 시스템을 만듬


# 기본구조
- 카프카 클러스터
    - 메세지를 저장하는 저장소
    - 하나의 여러개의 브로커(각각의 서버)로 구성이 됨
    - 브로커들이 메세지를 나눠서 저장, 이중화 처리, 장애가 나면 대체 함
    - 데이터를 이동하는데 필요한 핵심 역할을 맡음
- 주키퍼 클러스터(앙상블)
    - 카프카 클러스터 관리
    - 카프카 클러스터와 관련된 정보가 기록이되고 관리가 됨
- 프로듀서(producer)
    - 카프카 클러스터에 메시지를 보냄
- 컨슈머(consumer)
    - 카프카 클러스터에서 메세지를 읽음


### 토픽과 파티션
- 토픽은 메시지를 구분하는 단위: 파일시스템의 폴더와 유사
- 한 개의 토픽은 한 개 이상의 파티션으로 구성
  - 파티션은 메시지를 저장하는 물리적인 파일
- 각각의 메시지를 알맞게 구분하기 위한 목적으로 사용
- 프로듀서와 컨슈머가 토픽을 기준으로 메시지를 주고 받음

[kafka](https://kafka.apache.org)
[참고 사이트](https://freedeveloper.tistory.com/category/DevOps/Kafka)
[깔끔한 개념정리 사이트](https://www.tibco.com/ko/reference-center/what-is-apache-kafka)

위 사이트를 토대로 추가 공부후 계속 정리 예정